#!/usr/bin/env python3
"""
SAINT.OS Node Manager

Manages simulated SAINT.OS nodes in Renode:
- Create new nodes with unique IDs and persistent storage
- Start/stop individual nodes
- List node status
- Clear node storage (factory reset)

Usage:
    ./saint_node_manager.py create <node_id> [--port PORT]
    ./saint_node_manager.py start <node_id>
    ./saint_node_manager.py stop <node_id>
    ./saint_node_manager.py list
    ./saint_node_manager.py reset <node_id>
    ./saint_node_manager.py start-all
    ./saint_node_manager.py stop-all
"""

import argparse
import json
import os
import signal
import subprocess
import sys
import time
from pathlib import Path

# Configuration - paths relative to this script's location
SCRIPT_DIR = Path(__file__).parent.resolve()
FIRMWARE_DIR = SCRIPT_DIR.parent
PROJECT_DIR = FIRMWARE_DIR.parent.parent.parent  # saint_os/

RENODE_PATH = os.path.expanduser("~/Applications/Renode.app/Contents/MacOS/Renode")
RENODE_RP2040_PATH = SCRIPT_DIR / "renode_rp2040"
FIRMWARE_PATH = FIRMWARE_DIR / "build" / "saint_node.elf"
NODES_DIR = SCRIPT_DIR / "nodes"
STORAGE_DIR = SCRIPT_DIR / "node_storage"
STATE_FILE = SCRIPT_DIR / "nodes.json"

# Base UDP port for nodes (each node gets consecutive port)
BASE_UDP_PORT = 9999


def ensure_dirs():
    """Create necessary directories."""
    STORAGE_DIR.mkdir(parents=True, exist_ok=True)
    NODES_DIR.mkdir(parents=True, exist_ok=True)


def load_state():
    """Load node state from file."""
    if STATE_FILE.exists():
        with open(STATE_FILE, "r") as f:
            return json.load(f)
    return {"nodes": {}, "next_port": BASE_UDP_PORT}


def save_state(state):
    """Save node state to file."""
    with open(STATE_FILE, "w") as f:
        json.dump(state, f, indent=2)


def generate_resc_script(node_id, udp_port):
    """Generate a Renode script for a specific node."""
    # Script configures peripherals via properties after loading the standard platform
    script = f'''# SAINT.OS Node: {node_id}
# Auto-generated by saint_node_manager.py

$machine_name="{node_id}"

path add @{RENODE_RP2040_PATH}

# Include peripheral C# definitions and create machine
include @{RENODE_RP2040_PATH}/cores/initialize_peripherals_simple.resc

# Load standard platform (includes default peripheral instances)
machine LoadPlatformDescription @{RENODE_RP2040_PATH}/boards/adafruit_feather_rp2040.repl

# Configure peripherals for this specific node
sysbus.persistent_storage StoragePath "{STORAGE_DIR}"
sysbus.persistent_storage NodeId "{node_id}"
sysbus.udp_bridge LocalPort {udp_port}

# Load bootrom and firmware
sysbus LoadELF @{RENODE_RP2040_PATH}/bootroms/rp2040/b2.elf
sysbus LoadELF @{FIRMWARE_PATH}

# Set vector table
sysbus.cpu0 VectorTableOffset 0x00000000
sysbus.cpu1 VectorTableOffset 0x00000000

# Show UART for debug
showAnalyzer sysbus.uart0

logLevel 3 sysbus.uart0

echo "=============================================="
echo "SAINT.OS Node: {node_id}"
echo "=============================================="
echo ""
echo "  UDP Port: {udp_port}"
echo "  Storage: {STORAGE_DIR}/{node_id}.bin"
echo ""
echo "Commands:"
echo "  start    - Start simulation"
echo "  pause    - Pause simulation"
echo "  quit     - Exit Renode"
echo ""

# Auto-start the simulation
start
'''
    return script


def create_node(node_id, port=None):
    """Create a new node configuration."""
    ensure_dirs()
    state = load_state()

    if node_id in state["nodes"]:
        print(f"Error: Node '{node_id}' already exists")
        return False

    # Assign port
    if port is None:
        port = state["next_port"]
        state["next_port"] = port - 1  # Decrement for next node

    # Create node entry
    state["nodes"][node_id] = {
        "id": node_id,
        "udp_port": port,
        "created": time.strftime("%Y-%m-%d %H:%M:%S"),
        "pid": None,
    }

    # Generate RESC script
    os.makedirs(NODES_DIR, exist_ok=True)

    script_content = generate_resc_script(node_id, port)
    script_path = NODES_DIR / f"{node_id}.resc"

    with open(script_path, "w") as f:
        f.write(script_content)

    save_state(state)
    print(f"Created node '{node_id}' on UDP port {port}")
    print(f"  Script: {script_path}")
    print(f"  Storage: {STORAGE_DIR}/{node_id}.bin")
    return True


def start_node(node_id, wait=False):
    """Start a node in Renode."""
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist. Create it first.")
        return False

    node = state["nodes"][node_id]
    if node.get("pid"):
        # Check if process is still running
        try:
            os.kill(node["pid"], 0)
            print(f"Node '{node_id}' is already running (PID {node['pid']})")
            return True
        except OSError:
            # Process not running, clear PID
            node["pid"] = None

    script_path = NODES_DIR / f"{node_id}.resc"
    if not script_path.exists():
        print(f"Error: Script not found: {script_path}")
        return False

    # Start Renode
    cmd = [RENODE_PATH, str(script_path)]
    if wait:
        # Run in foreground
        process = subprocess.Popen(cmd)
        node["pid"] = process.pid
        save_state(state)
        print(f"Started node '{node_id}' (PID {process.pid})")
        process.wait()
        node["pid"] = None
        save_state(state)
    else:
        # Run in background
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True,
        )
        node["pid"] = process.pid
        save_state(state)
        print(f"Started node '{node_id}' in background (PID {process.pid})")

    return True


def stop_node(node_id):
    """Stop a running node."""
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist")
        return False

    node = state["nodes"][node_id]
    pid = node.get("pid")

    if not pid:
        print(f"Node '{node_id}' is not running")
        return True

    try:
        os.kill(pid, signal.SIGTERM)
        # Wait a moment for graceful shutdown
        time.sleep(1)
        try:
            os.kill(pid, 0)
            # Still running, force kill
            os.kill(pid, signal.SIGKILL)
        except OSError:
            pass
        print(f"Stopped node '{node_id}'")
    except OSError as e:
        print(f"Could not stop node '{node_id}': {e}")

    node["pid"] = None
    save_state(state)
    return True


def list_nodes():
    """List all nodes and their status."""
    state = load_state()

    if not state["nodes"]:
        print("No nodes configured")
        return

    print(f"{'Node ID':<20} {'UDP Port':<10} {'Status':<15} {'Storage'}")
    print("-" * 70)

    for node_id, node in state["nodes"].items():
        # Check if running
        pid = node.get("pid")
        running = False
        if pid:
            try:
                os.kill(pid, 0)
                running = True
            except OSError:
                pass

        status = f"Running (PID {pid})" if running else "Stopped"

        # Check if storage exists
        storage_path = STORAGE_DIR / f"{node_id}.bin"
        has_storage = "Yes" if storage_path.exists() else "No"

        print(f"{node_id:<20} {node['udp_port']:<10} {status:<15} {has_storage}")


def reset_node(node_id):
    """Reset a node's persistent storage (factory reset)."""
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist")
        return False

    storage_path = STORAGE_DIR / f"{node_id}.bin"
    if storage_path.exists():
        storage_path.unlink()
        print(f"Cleared storage for node '{node_id}'")
    else:
        print(f"No storage found for node '{node_id}'")

    return True


def delete_node(node_id):
    """Delete a node completely."""
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist")
        return False

    # Stop if running
    stop_node(node_id)

    # Remove storage
    storage_path = STORAGE_DIR / f"{node_id}.bin"
    if storage_path.exists():
        storage_path.unlink()

    # Remove script file
    script_path = NODES_DIR / f"{node_id}.resc"
    if script_path.exists():
        script_path.unlink()

    # Remove from state
    del state["nodes"][node_id]
    save_state(state)

    print(f"Deleted node '{node_id}'")
    return True


def start_all():
    """Start all nodes."""
    state = load_state()
    for node_id in state["nodes"]:
        start_node(node_id, wait=False)


def stop_all():
    """Stop all running nodes."""
    state = load_state()
    for node_id in state["nodes"]:
        stop_node(node_id)


def main():
    parser = argparse.ArgumentParser(description="SAINT.OS Node Manager")
    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Create command
    create_parser = subparsers.add_parser("create", help="Create a new node")
    create_parser.add_argument("node_id", help="Unique node identifier")
    create_parser.add_argument("--port", type=int, help="UDP port (auto-assigned if not specified)")

    # Start command
    start_parser = subparsers.add_parser("start", help="Start a node")
    start_parser.add_argument("node_id", help="Node to start")
    start_parser.add_argument("--wait", action="store_true", help="Wait for Renode to exit")

    # Stop command
    stop_parser = subparsers.add_parser("stop", help="Stop a running node")
    stop_parser.add_argument("node_id", help="Node to stop")

    # List command
    subparsers.add_parser("list", help="List all nodes")

    # Reset command
    reset_parser = subparsers.add_parser("reset", help="Reset node storage (factory reset)")
    reset_parser.add_argument("node_id", help="Node to reset")

    # Delete command
    delete_parser = subparsers.add_parser("delete", help="Delete a node completely")
    delete_parser.add_argument("node_id", help="Node to delete")

    # Start-all command
    subparsers.add_parser("start-all", help="Start all nodes")

    # Stop-all command
    subparsers.add_parser("stop-all", help="Stop all running nodes")

    args = parser.parse_args()

    if args.command == "create":
        create_node(args.node_id, args.port)
    elif args.command == "start":
        start_node(args.node_id, args.wait)
    elif args.command == "stop":
        stop_node(args.node_id)
    elif args.command == "list":
        list_nodes()
    elif args.command == "reset":
        reset_node(args.node_id)
    elif args.command == "delete":
        delete_node(args.node_id)
    elif args.command == "start-all":
        start_all()
    elif args.command == "stop-all":
        stop_all()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
