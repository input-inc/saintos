#!/usr/bin/env python3
"""
SAINT.OS Node Manager

Manages simulated SAINT.OS nodes in Renode:
- Create new nodes with unique IDs and persistent storage
- Start/stop individual nodes
- List node status
- Clear node storage (factory reset)

Usage:
    ./saint_node_manager.py create <node_id> [--port PORT]
    ./saint_node_manager.py start <node_id>
    ./saint_node_manager.py stop <node_id>
    ./saint_node_manager.py list
    ./saint_node_manager.py reset <node_id>
    ./saint_node_manager.py start-all
    ./saint_node_manager.py stop-all
    ./saint_node_manager.py update [<node_id>]      # Install firmware and optionally restart node
    ./saint_node_manager.py restart <node_id>       # Restart a node
    ./saint_node_manager.py regenerate [<node_id>]  # Regenerate RESC scripts with current paths
"""

import argparse
import json
import os
import signal
import subprocess
import sys
import time
from pathlib import Path

# Configuration - paths relative to this script's location
SCRIPT_DIR = Path(__file__).parent.resolve()
FIRMWARE_DIR = SCRIPT_DIR.parent
PROJECT_DIR = FIRMWARE_DIR.parent.parent.parent  # saint_os/

RENODE_PATH = os.path.expanduser("~/Applications/Renode.app/Contents/MacOS/Renode")
RENODE_RP2040_PATH = SCRIPT_DIR / "renode_rp2040"

# Firmware paths
# - INSTALL_DIR: Where Renode loads firmware from (what nodes run)
# - BUILD_DIR: Where new builds are created (what's available for update)
INSTALL_DIR = FIRMWARE_DIR / "install" / "simulation"
BUILD_DIR = FIRMWARE_DIR / "build_sim"
FIRMWARE_PATH = INSTALL_DIR / "saint_node.elf"  # Renode loads from install dir

NODES_DIR = SCRIPT_DIR / "nodes"
STORAGE_DIR = SCRIPT_DIR / "node_storage"
LOGS_DIR = SCRIPT_DIR / "logs"
STATE_FILE = SCRIPT_DIR / "nodes.json"

# Base UDP port for nodes (each node gets consecutive port)
BASE_UDP_PORT = 9999


def ensure_dirs():
    """Create necessary directories."""
    STORAGE_DIR.mkdir(parents=True, exist_ok=True)
    NODES_DIR.mkdir(parents=True, exist_ok=True)
    LOGS_DIR.mkdir(parents=True, exist_ok=True)
    INSTALL_DIR.mkdir(parents=True, exist_ok=True)


def load_state():
    """Load node state from file."""
    if STATE_FILE.exists():
        with open(STATE_FILE, "r") as f:
            return json.load(f)
    return {"nodes": {}, "next_port": BASE_UDP_PORT}


def save_state(state):
    """Save node state to file."""
    with open(STATE_FILE, "w") as f:
        json.dump(state, f, indent=2)


def generate_resc_script(node_id, udp_port):
    """Generate a Renode script for a specific node."""
    # Script configures peripherals via properties after loading the standard platform
    script = f'''# SAINT.OS Node: {node_id}
# Auto-generated by saint_node_manager.py

$machine_name="{node_id}"

path add @{RENODE_RP2040_PATH}

# Include peripheral C# definitions and create machine
include @{RENODE_RP2040_PATH}/cores/initialize_peripherals_simple.resc

# Load standard platform (includes default peripheral instances)
machine LoadPlatformDescription @{RENODE_RP2040_PATH}/boards/adafruit_feather_rp2040.repl

# Configure peripherals for this specific node
sysbus.persistent_storage StoragePath "{STORAGE_DIR}"
sysbus.persistent_storage NodeId "{node_id}"
sysbus.udp_bridge LocalPort {udp_port}

# Load bootrom and firmware
sysbus LoadELF @{RENODE_RP2040_PATH}/bootroms/rp2040/b2.elf
sysbus LoadELF @{FIRMWARE_PATH}

# Set vector table
sysbus.cpu0 VectorTableOffset 0x00000000
sysbus.cpu1 VectorTableOffset 0x00000000

# Keep cpu1 halted - RP2040 firmware will start it when needed
# This prevents Renode dual-core issues
cpu1 IsHalted true

# Log Renode system messages to file
logFile @{LOGS_DIR}/{node_id}_renode.log true

# Show UART output in Renode console (firmware printf goes here)
showAnalyzer sysbus.uart0

echo "=============================================="
echo "SAINT.OS Node: {node_id}"
echo "=============================================="
echo ""
echo "  UDP Port: {udp_port}"
echo "  Storage: {STORAGE_DIR}/{node_id}.bin"
echo "  Log File: {LOGS_DIR}/{node_id}_uart.log"
echo ""
echo "To view output:"
echo "  tail -f {LOGS_DIR}/{node_id}_uart.log"
echo ""
echo "Commands:"
echo "  start    - Start simulation"
echo "  pause    - Pause simulation"
echo "  quit     - Exit Renode"
echo ""

# Auto-start the simulation
start
'''
    return script


def create_node(node_id, port=None):
    """Create a new node configuration."""
    ensure_dirs()
    state = load_state()

    if node_id in state["nodes"]:
        print(f"Error: Node '{node_id}' already exists")
        return False

    # Assign port
    if port is None:
        port = state["next_port"]
        state["next_port"] = port - 1  # Decrement for next node

    # Create node entry
    state["nodes"][node_id] = {
        "id": node_id,
        "udp_port": port,
        "created": time.strftime("%Y-%m-%d %H:%M:%S"),
        "pid": None,
    }

    # Generate RESC script
    os.makedirs(NODES_DIR, exist_ok=True)

    script_content = generate_resc_script(node_id, port)
    script_path = NODES_DIR / f"{node_id}.resc"

    with open(script_path, "w") as f:
        f.write(script_content)

    save_state(state)
    print(f"Created node '{node_id}' on UDP port {port}")
    print(f"  Script: {script_path}")
    print(f"  Storage: {STORAGE_DIR}/{node_id}.bin")
    return True


def start_node(node_id, wait=False):
    """Start a node in Renode."""
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist. Create it first.")
        return False

    node = state["nodes"][node_id]
    if node.get("pid"):
        # Check if process is still running
        try:
            os.kill(node["pid"], 0)
            print(f"Node '{node_id}' is already running (PID {node['pid']})")
            return True
        except OSError:
            # Process not running, clear PID
            node["pid"] = None

    script_path = NODES_DIR / f"{node_id}.resc"
    if not script_path.exists():
        print(f"Error: Script not found: {script_path}")
        return False

    # Start Renode
    cmd = [RENODE_PATH, str(script_path)]
    if wait:
        # Run in foreground
        process = subprocess.Popen(cmd)
        node["pid"] = process.pid
        save_state(state)
        print(f"Started node '{node_id}' (PID {process.pid})")
        process.wait()
        node["pid"] = None
        save_state(state)
    else:
        # Run in background
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True,
        )
        node["pid"] = process.pid
        save_state(state)
        print(f"Started node '{node_id}' in background (PID {process.pid})")

    return True


def stop_node(node_id):
    """Stop a running node."""
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist")
        return False

    node = state["nodes"][node_id]
    pid = node.get("pid")

    if not pid:
        print(f"Node '{node_id}' is not running")
        return True

    try:
        os.kill(pid, signal.SIGTERM)
        # Wait a moment for graceful shutdown
        time.sleep(1)
        try:
            os.kill(pid, 0)
            # Still running, force kill
            os.kill(pid, signal.SIGKILL)
        except OSError:
            pass
        print(f"Stopped node '{node_id}'")
    except OSError as e:
        print(f"Could not stop node '{node_id}': {e}")

    node["pid"] = None
    save_state(state)
    return True


def get_installed_firmware_info():
    """Get information about the installed firmware."""
    version_file = INSTALL_DIR / "version.h"
    elf_file = INSTALL_DIR / "saint_node.elf"

    info = {
        "available": elf_file.exists(),
        "path": str(INSTALL_DIR),
        "version": None,
        "build_date": None,
    }

    if version_file.exists():
        import re
        with open(version_file, "r") as f:
            content = f.read()

        # Parse version info from version.h
        # Try FIRMWARE_VERSION_FULL first (includes git hash)
        version_match = re.search(r'#define\s+FIRMWARE_VERSION_FULL\s+"([^"]+)"', content)
        if not version_match:
            version_match = re.search(r'#define\s+FIRMWARE_VERSION_STRING\s+"([^"]+)"', content)

        date_match = re.search(r'#define\s+FIRMWARE_BUILD_TIMESTAMP\s+"([^"]+)"', content)

        if version_match:
            info["version"] = version_match.group(1)
        if date_match:
            info["build_date"] = date_match.group(1)

    return info


def list_nodes():
    """List all nodes and their status."""
    state = load_state()

    # Show firmware info first
    fw_info = get_installed_firmware_info()
    print("Firmware:")
    if fw_info["available"]:
        print(f"  Location: {fw_info['path']}")
        print(f"  Version:  {fw_info.get('version', 'unknown')} ({fw_info.get('build_date', 'unknown')})")
    else:
        print(f"  Not installed (run 'make install_sim' in build_sim/)")
    print()

    if not state["nodes"]:
        print("No nodes configured")
        return

    print(f"{'Node ID':<20} {'UDP Port':<10} {'Status':<15} {'Storage'}")
    print("-" * 70)

    for node_id, node in state["nodes"].items():
        # Check if running
        pid = node.get("pid")
        running = False
        if pid:
            try:
                os.kill(pid, 0)
                running = True
            except OSError:
                pass

        status = f"Running (PID {pid})" if running else "Stopped"

        # Check if storage exists
        storage_path = STORAGE_DIR / f"{node_id}.bin"
        has_storage = "Yes" if storage_path.exists() else "No"

        print(f"{node_id:<20} {node['udp_port']:<10} {status:<15} {has_storage}")


def reset_node(node_id):
    """Reset a node's persistent storage (factory reset)."""
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist")
        return False

    storage_path = STORAGE_DIR / f"{node_id}.bin"
    if storage_path.exists():
        storage_path.unlink()
        print(f"Cleared storage for node '{node_id}'")
    else:
        print(f"No storage found for node '{node_id}'")

    return True


def delete_node(node_id):
    """Delete a node completely."""
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist")
        return False

    # Stop if running
    stop_node(node_id)

    # Remove storage
    storage_path = STORAGE_DIR / f"{node_id}.bin"
    if storage_path.exists():
        storage_path.unlink()

    # Remove script file
    script_path = NODES_DIR / f"{node_id}.resc"
    if script_path.exists():
        script_path.unlink()

    # Remove from state
    del state["nodes"][node_id]
    save_state(state)

    print(f"Deleted node '{node_id}'")
    return True


def start_all():
    """Start all nodes."""
    state = load_state()
    for node_id in state["nodes"]:
        start_node(node_id, wait=False)


def stop_all():
    """Stop all running nodes."""
    state = load_state()
    for node_id in state["nodes"]:
        stop_node(node_id)


def update_firmware(node_id=None):
    """
    Update firmware by copying from build_sim to install directory.

    If node_id is specified, also restarts that node.
    If node_id is None, just copies the firmware (for manual restart).
    """
    # Check if build exists
    build_elf = BUILD_DIR / "saint_node.elf"
    build_version = BUILD_DIR / "generated" / "version.h"

    if not build_elf.exists():
        print(f"Error: No firmware build found at {build_elf}")
        print("Run 'make' in build_sim directory first")
        return False

    # Ensure install directory exists
    INSTALL_DIR.mkdir(parents=True, exist_ok=True)

    # Copy firmware files
    import shutil

    install_elf = INSTALL_DIR / "saint_node.elf"
    install_version = INSTALL_DIR / "version.h"

    print(f"Copying firmware from {BUILD_DIR} to {INSTALL_DIR}")
    shutil.copy2(build_elf, install_elf)
    print(f"  Copied: saint_node.elf")

    if build_version.exists():
        shutil.copy2(build_version, install_version)
        print(f"  Copied: version.h")

    print(f"Firmware installed to {INSTALL_DIR}")

    # Restart node if specified
    if node_id:
        print(f"\nRestarting node '{node_id}'...")
        stop_node(node_id)
        time.sleep(1)  # Give it a moment to fully stop
        start_node(node_id, wait=False)

    return True


def restart_node(node_id):
    """Restart a node (stop then start)."""
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist")
        return False

    print(f"Restarting node '{node_id}'...")
    stop_node(node_id)
    time.sleep(1)  # Give it a moment to fully stop
    start_node(node_id, wait=False)
    return True


def regenerate_script(node_id):
    """Regenerate the RESC script for a node with current paths.

    This is useful after updating the node manager to use new paths.
    """
    state = load_state()

    if node_id not in state["nodes"]:
        print(f"Error: Node '{node_id}' does not exist")
        return False

    node = state["nodes"][node_id]
    port = node["udp_port"]

    # Generate new script with current paths
    script_content = generate_resc_script(node_id, port)
    script_path = NODES_DIR / f"{node_id}.resc"

    with open(script_path, "w") as f:
        f.write(script_content)

    print(f"Regenerated script for node '{node_id}'")
    print(f"  Firmware: {FIRMWARE_PATH}")
    return True


def regenerate_all_scripts():
    """Regenerate RESC scripts for all nodes."""
    state = load_state()

    if not state["nodes"]:
        print("No nodes configured")
        return

    for node_id in state["nodes"]:
        regenerate_script(node_id)


def main():
    parser = argparse.ArgumentParser(description="SAINT.OS Node Manager")
    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Create command
    create_parser = subparsers.add_parser("create", help="Create a new node")
    create_parser.add_argument("node_id", help="Unique node identifier")
    create_parser.add_argument("--port", type=int, help="UDP port (auto-assigned if not specified)")

    # Start command
    start_parser = subparsers.add_parser("start", help="Start a node")
    start_parser.add_argument("node_id", help="Node to start")
    start_parser.add_argument("--wait", action="store_true", help="Wait for Renode to exit")

    # Stop command
    stop_parser = subparsers.add_parser("stop", help="Stop a running node")
    stop_parser.add_argument("node_id", help="Node to stop")

    # List command
    subparsers.add_parser("list", help="List all nodes")

    # Reset command
    reset_parser = subparsers.add_parser("reset", help="Reset node storage (factory reset)")
    reset_parser.add_argument("node_id", help="Node to reset")

    # Delete command
    delete_parser = subparsers.add_parser("delete", help="Delete a node completely")
    delete_parser.add_argument("node_id", help="Node to delete")

    # Start-all command
    subparsers.add_parser("start-all", help="Start all nodes")

    # Stop-all command
    subparsers.add_parser("stop-all", help="Stop all running nodes")

    # Update command
    update_parser = subparsers.add_parser(
        "update", help="Install new firmware from build_sim to install directory"
    )
    update_parser.add_argument(
        "node_id", nargs="?", help="Optional node to restart after update"
    )

    # Restart command
    restart_parser = subparsers.add_parser("restart", help="Restart a node")
    restart_parser.add_argument("node_id", help="Node to restart")

    # Regenerate command
    regen_parser = subparsers.add_parser(
        "regenerate", help="Regenerate RESC script with current paths"
    )
    regen_parser.add_argument(
        "node_id", nargs="?", help="Node to regenerate (all if not specified)"
    )

    args = parser.parse_args()

    if args.command == "create":
        create_node(args.node_id, args.port)
    elif args.command == "start":
        start_node(args.node_id, args.wait)
    elif args.command == "stop":
        stop_node(args.node_id)
    elif args.command == "list":
        list_nodes()
    elif args.command == "reset":
        reset_node(args.node_id)
    elif args.command == "delete":
        delete_node(args.node_id)
    elif args.command == "start-all":
        start_all()
    elif args.command == "stop-all":
        stop_all()
    elif args.command == "update":
        update_firmware(args.node_id)
    elif args.command == "restart":
        restart_node(args.node_id)
    elif args.command == "regenerate":
        if args.node_id:
            regenerate_script(args.node_id)
        else:
            regenerate_all_scripts()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
