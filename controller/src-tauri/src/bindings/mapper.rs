use super::config::*;
use crate::input::manager::InputState;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// Mapped command ready to send to the server
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MappedCommand {
    pub node_id: String,
    pub pin_id: u32,
    pub value: Value,
}

/// Action events generated by input processing
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ActionEvent {
    /// Send a control command
    Command(MappedCommand),
    /// Show a preset panel
    ShowPanel { panel_id: String },
    /// Hide the current panel
    HidePanel,
    /// Navigate within a panel
    NavigatePanel { direction: NavigateDirection },
    /// Select the current panel item
    SelectPanelItem,
    /// Activate a specific preset
    ActivatePreset { preset_id: String },
    /// Toggle an output
    ToggleOutput { target_id: String },
    /// Cycle through output values
    CycleOutput { target_id: String, value: String },
    /// Emergency stop
    EStop,
}

/// Panel navigation state
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct PanelState {
    pub active_panel_id: Option<String>,
    pub selected_index: usize,
    pub current_page: usize,
}

/// Maps input state to commands and actions based on bindings
pub struct InputMapper {
    profiles: Vec<BindingProfile>,
    active_profile_id: String,
    last_analog_values: HashMap<String, f32>,
    last_button_states: HashMap<String, bool>,
    panel_state: PanelState,
    cycle_indices: HashMap<String, usize>,
    toggle_states: HashMap<String, bool>,
    modifier_values: HashMap<String, f32>,
}

impl InputMapper {
    pub fn new() -> Self {
        Self {
            profiles: vec![super::presets::create_default_profile()],
            active_profile_id: "default".to_string(),
            last_analog_values: HashMap::new(),
            last_button_states: HashMap::new(),
            panel_state: PanelState::default(),
            cycle_indices: HashMap::new(),
            toggle_states: HashMap::new(),
            modifier_values: HashMap::new(),
        }
    }

    pub fn get_profiles(&self) -> &[BindingProfile] {
        &self.profiles
    }

    pub fn set_profiles(&mut self, profiles: Vec<BindingProfile>) {
        self.profiles = profiles;
        if !self.profiles.iter().any(|p| p.id == self.active_profile_id) {
            self.active_profile_id = self
                .profiles
                .first()
                .map(|p| p.id.clone())
                .unwrap_or_default();
        }
    }

    pub fn set_active_profile(&mut self, profile_id: &str) {
        if self.profiles.iter().any(|p| p.id == profile_id) {
            self.active_profile_id = profile_id.to_string();
        }
    }

    pub fn active_profile(&self) -> Option<&BindingProfile> {
        self.profiles
            .iter()
            .find(|p| p.id == self.active_profile_id)
    }

    pub fn panel_state(&self) -> &PanelState {
        &self.panel_state
    }

    /// Process input state and generate action events
    pub fn process(&mut self, input: &InputState) -> Vec<ActionEvent> {
        let profile = match self.active_profile() {
            Some(p) => p.clone(),
            None => return Vec::new(),
        };

        let mut events = Vec::new();

        // Process analog bindings
        self.process_analog_bindings(&profile, input, &mut events);

        // Process digital bindings
        self.process_digital_bindings(&profile, input, &mut events);

        events
    }

    fn process_analog_bindings(
        &mut self,
        profile: &BindingProfile,
        input: &InputState,
        events: &mut Vec<ActionEvent>,
    ) {
        for binding in &profile.analog_bindings {
            if !binding.enabled {
                continue;
            }

            let raw_value = self.get_analog_value(input, &binding.input);

            match &binding.action {
                AnalogAction::DirectControl { target, transform } => {
                    let transformed = transform.apply(raw_value);

                    // Apply modifiers
                    let modified = self.apply_modifiers(transformed);

                    let key = format!("{:?}", binding.input);
                    let last = self.last_analog_values.get(&key).copied().unwrap_or(0.0);
                    let delta = (modified - last).abs();

                    if delta > 0.001 {
                        self.last_analog_values.insert(key, modified);

                        events.push(ActionEvent::Command(MappedCommand {
                            node_id: target.node_id.clone(),
                            pin_id: target.pin_id,
                            value: Value::from(modified),
                        }));
                    }
                }
                AnalogAction::Modifier { effect } => {
                    // Store modifier value for use by other bindings
                    match effect {
                        ModifierEffect::PrecisionMode { .. } => {
                            self.modifier_values.insert("precision".to_string(), raw_value);
                        }
                        ModifierEffect::SpeedBoost { .. } => {
                            self.modifier_values.insert("speed_boost".to_string(), raw_value);
                        }
                        ModifierEffect::ScaleTarget { target_id, .. } => {
                            self.modifier_values.insert(target_id.clone(), raw_value);
                        }
                    }
                }
            }
        }
    }

    fn process_digital_bindings(
        &mut self,
        profile: &BindingProfile,
        input: &InputState,
        events: &mut Vec<ActionEvent>,
    ) {
        for binding in &profile.digital_bindings {
            if !binding.enabled {
                continue;
            }

            let pressed = self.get_button_pressed(input, &binding.input);
            let key = format!("{:?}", binding.input);
            let was_pressed = self.last_button_states.get(&key).copied().unwrap_or(false);
            self.last_button_states.insert(key.clone(), pressed);

            // For now, handle Press trigger (TODO: implement Hold, DoubleTap, LongPress)
            let triggered = match binding.trigger {
                ButtonTrigger::Press => pressed && !was_pressed,
                ButtonTrigger::Release => !pressed && was_pressed,
                _ => false, // TODO: implement other triggers
            };

            if !triggered {
                continue;
            }

            match &binding.action {
                DigitalAction::ShowPanel { panel_id } => {
                    if self.panel_state.active_panel_id.as_ref() == Some(panel_id) {
                        // Toggle off if same panel
                        self.panel_state.active_panel_id = None;
                        events.push(ActionEvent::HidePanel);
                    } else {
                        self.panel_state.active_panel_id = Some(panel_id.clone());
                        self.panel_state.selected_index = 0;
                        self.panel_state.current_page = 0;
                        events.push(ActionEvent::ShowPanel {
                            panel_id: panel_id.clone(),
                        });
                    }
                }
                DigitalAction::HidePanel => {
                    self.panel_state.active_panel_id = None;
                    events.push(ActionEvent::HidePanel);
                }
                DigitalAction::NavigatePanel { direction } => {
                    if self.panel_state.active_panel_id.is_some() {
                        self.navigate_panel(profile, direction);
                        events.push(ActionEvent::NavigatePanel {
                            direction: direction.clone(),
                        });
                    }
                }
                DigitalAction::SelectPanelItem => {
                    if let Some(panel_id) = &self.panel_state.active_panel_id {
                        if let Some(panel) = profile.get_panel(panel_id) {
                            if let Some(preset) = panel.presets.get(self.panel_state.selected_index)
                            {
                                events.push(ActionEvent::ActivatePreset {
                                    preset_id: preset.id.clone(),
                                });
                            }
                        }
                    }
                }
                DigitalAction::ActivatePreset { preset_id } => {
                    events.push(ActionEvent::ActivatePreset {
                        preset_id: preset_id.clone(),
                    });
                }
                DigitalAction::ToggleOutput { target_id } => {
                    let current = self.toggle_states.get(target_id).copied().unwrap_or(false);
                    self.toggle_states.insert(target_id.clone(), !current);
                    events.push(ActionEvent::ToggleOutput {
                        target_id: target_id.clone(),
                    });
                }
                DigitalAction::CycleOutput { target_id, values } => {
                    if !values.is_empty() {
                        let idx = self.cycle_indices.get(target_id).copied().unwrap_or(0);
                        let next_idx = (idx + 1) % values.len();
                        self.cycle_indices.insert(target_id.clone(), next_idx);
                        events.push(ActionEvent::CycleOutput {
                            target_id: target_id.clone(),
                            value: values[next_idx].clone(),
                        });
                    }
                }
                DigitalAction::DirectControl { target, value } => {
                    events.push(ActionEvent::Command(MappedCommand {
                        node_id: target.node_id.clone(),
                        pin_id: target.pin_id,
                        value: Value::from(*value),
                    }));
                }
                DigitalAction::EStop => {
                    events.push(ActionEvent::EStop);
                }
                DigitalAction::None => {}
            }
        }
    }

    fn navigate_panel(&mut self, profile: &BindingProfile, direction: &NavigateDirection) {
        if let Some(panel_id) = &self.panel_state.active_panel_id {
            if let Some(panel) = profile.get_panel(panel_id) {
                let total_items = panel.presets.len();
                let items_per_page = panel.items_per_page as usize;
                let total_pages = (total_items + items_per_page - 1) / items_per_page;

                match direction {
                    NavigateDirection::NextItem => {
                        if self.panel_state.selected_index + 1 < total_items {
                            self.panel_state.selected_index += 1;
                            // Update page if needed
                            self.panel_state.current_page =
                                self.panel_state.selected_index / items_per_page;
                        }
                    }
                    NavigateDirection::PrevItem => {
                        if self.panel_state.selected_index > 0 {
                            self.panel_state.selected_index -= 1;
                            self.panel_state.current_page =
                                self.panel_state.selected_index / items_per_page;
                        }
                    }
                    NavigateDirection::NextPage => {
                        if self.panel_state.current_page + 1 < total_pages {
                            self.panel_state.current_page += 1;
                            self.panel_state.selected_index =
                                self.panel_state.current_page * items_per_page;
                        }
                    }
                    NavigateDirection::PrevPage => {
                        if self.panel_state.current_page > 0 {
                            self.panel_state.current_page -= 1;
                            self.panel_state.selected_index =
                                self.panel_state.current_page * items_per_page;
                        }
                    }
                }
            }
        }
    }

    fn get_analog_value(&self, input: &InputState, analog: &AnalogInput) -> f32 {
        match analog {
            AnalogInput::LeftStickX => input.gamepad.left_stick.x,
            AnalogInput::LeftStickY => input.gamepad.left_stick.y,
            AnalogInput::RightStickX => input.gamepad.right_stick.x,
            AnalogInput::RightStickY => input.gamepad.right_stick.y,
            AnalogInput::LeftTrigger => input.gamepad.left_trigger,
            AnalogInput::RightTrigger => input.gamepad.right_trigger,
        }
    }

    fn get_button_pressed(&self, input: &InputState, button: &DigitalInput) -> bool {
        let button_name = match button {
            DigitalInput::A => "A",
            DigitalInput::B => "B",
            DigitalInput::X => "X",
            DigitalInput::Y => "Y",
            DigitalInput::LB => "LB",
            DigitalInput::RB => "RB",
            DigitalInput::DPadUp => "DPadUp",
            DigitalInput::DPadDown => "DPadDown",
            DigitalInput::DPadLeft => "DPadLeft",
            DigitalInput::DPadRight => "DPadRight",
            DigitalInput::Start => "Start",
            DigitalInput::Select => "Select",
            DigitalInput::LeftStick => "LeftStick",
            DigitalInput::RightStick => "RightStick",
        };
        input.gamepad.buttons.get(button_name).copied().unwrap_or(false)
    }

    fn apply_modifiers(&self, value: f32) -> f32 {
        let mut result = value;

        // Apply precision mode (reduces output based on left trigger)
        if let Some(&precision) = self.modifier_values.get("precision") {
            if precision > 0.0 {
                // At full trigger, reduce to min_scale (e.g., 0.3)
                let min_scale = 0.3;
                let scale = 1.0 - (precision * (1.0 - min_scale));
                result *= scale;
            }
        }

        // Apply speed boost (increases output based on right trigger)
        if let Some(&boost) = self.modifier_values.get("speed_boost") {
            if boost > 0.0 {
                let max_boost = 1.5;
                let scale = 1.0 + (boost * (max_boost - 1.0));
                result *= scale;
            }
        }

        result.clamp(-1.0, 1.0)
    }
}

impl Default for InputMapper {
    fn default() -> Self {
        Self::new()
    }
}
